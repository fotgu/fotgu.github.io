---
date: '2025-03-12'
draft: true
title: '不要过早优化'
description: ''
summary: '删繁就简三秋树，领异标新二月花'
tags: ["工程思维"]
---

> We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.
>
> \-- Donald Knuth

## 坚持并传播正确原则

最近几周我好像总是在说服同事，**不要过早优化**。

同事有多年的工程经验，照理说应该被过早优化坑过很多次。

人总有自己的考虑，我们尊重他人意见，只是**坚持并传播正确的原则**。

## 几个反面案例

### 案例1:仅为减少RPC次数而合并不相关的接口

需求简化如下

1. 在帖子详情页--显示「互动数」和「前三个互动用户的头像列表」
2. 在互动详情页(从帖子详情页点击进入)--显示「互动数」和「所有互动用户的头像列表」

#### 同事的省流方案

- RPC 接口
  - detail 接口，提供互动数量和所有互动用户的信息(分页)
- 调用逻辑
  - 用户在帖子详情页时，调用一次 detail 接口；
  - 用户点击互动详情页时，不调用接口，直接用详情页获取的数据，直到用户滑动到分页结尾再去调用 detail 接口。
- 同事的思考
  - 假设帖子详情页和互动详情页的需求形态会一直相同；
  - 用户进入互动详情页后不需要额外调用接口，又快又节省服务器资源。

##### 我的四个质疑

1. 用户打开帖子详情页会慢(获取了额外的用户信息)
2. 由于用户不一定打开互动详情页，提前加载额外数据(多余的用户信息)会浪费服务器资源
3. 用户进入互动详情页后，看到的数据有延迟，且无法保证延迟时长(跟用户在帖子详情页的停留时间有关)
4. 帖子详情页的需求跟互动详情页的需求大概率会不一致，一旦变得不一致，还是要拆成两个接口

针对这四个问题，同事的回复如下：

1. 服务端做优化，加缓存
2. 设置场景参数，根据参数判断只加载3个用户，还是加载更多用户
3. 客户端根据在详情页停留时间判断是否要重新加载数据
4. 绑架产品决策，不让不一致（如果真能说服产品的话，也不是不行；但我怀疑是否真能说服）

可以看到，为了少调用一次 RPC 接口而强行合并接口，只能部分解决想象中的性能问题，同时会带来额外的问题。

#### 我的直给方案

- RPC 接口
  - stat 接口，提供互动数量和前三个互动用户的信息
  - detail 接口，提供互动数量和所有互动用户的信息(分页)
- 调用逻辑
  - 用户在帖子详情页时，只调用 stat 接口；
  - 用户点击互动详情页时，调用 detail 接口。

在我的思考过程中，没有考虑性能优化，只是从功能的正确性出发，很自然地得出了两个跟功能几乎完全对应的接口。

我没有把互动数拆成单独接口，因为从页面展示的一致性考虑，「互动数」和「头像列表长度」强相关，适合在一个接口内返回，这样能由服务端保证数据的一致性。

这个方案有性能问题吗？

首先从页面加载时间看，用户进入帖子详情页时，由于不需要拉全部的互动用户信息，所以会很快返回；

当用户点击互动详情页后，再去拉取互动用户的详细信息，这里需要根据实际的数据量和并发用户数考虑，在并发用户数少的时候不会有性能问题。

如果真的遇到了性能问题，也可以根据实际的瓶颈点，在客户端和服务端分别做优化：

1. 客户端在加载完帖子详情页后，提前加调用 detail 接口获取数据（不是很推荐，因为数据会有延迟）
2. 服务端通过~~加钱~~加多级缓存、加机器、加存储实例来水平扩容

总之，这个方案完全按照需求设计，不会在没有明确数据的情况下，为了想象中的性能收益去扭曲实现逻辑。

### 案例2:为(假想的)性能瓶颈做特化方案

需求简化如下

1. 用户搜索物品后，将搜索结果存入数据库
    > 搜索接口由其他部门提供，需要在本部门冗余存储（虽然也有点过度设计，但是我被说服了，毕竟有部门墙在，不好提需求）

#### 同事的快速响应方案

- RPC 接口
  - search 接口，提供其他部门搜索接口的代理
  - save 接口，用于持久化物品信息到数据库
- 调用逻辑
  - 用户搜索时，调用 search 接口，search 接口内部把物品信息写到缓存；
  - 用户选中结果后，调用 save 接口但是只传 id，接口内部根据 id 把 缓存的内容写到数据库。
- 背后思考
  - 假设数据库很慢，慢到来不及把搜索结果写入数据库后再返回给用户。同时认为缓存很快，可以先把搜索结果写到缓存；
  - 假设用户搜索的结果很多，为了节省空间，只把用户选中的物品信息存储到数据库；
    > 为啥不让客户端在调用 save 接口时把物品信息带过来呢？因为出于安全考虑，不要相信客户端。

##### 我的三个质疑

1. 用户选中结果后会进入物品详情页，持久化完成之前，必须通过缓存获取信息，这会污染所有要拿物品信息的接口
2. 存储到数据库可能失败，如果要保证存储的最终完成，需要使用巡检、重试队列、甚至人工介入等容错机制
3. 客户端增加了不必要的复杂度（本来可以在服务端解决，客户端不需要感知这件事）

针对这三个问题，同事也没有什么好办法。

#### 我的暴力同步写入方案

- RPC 接口
  - search 接口，提供其他部门搜索接口的代理
- 调用逻辑
  - 用户搜索时，调用 search 接口，search 接口内部把物品信息写到数据库，写入完成后再向用户返回结果。

在这里，我同样没有考虑性能优化，只是从数据的持久性和不暴露服务端内部细节的角度出发，得到了一个看起来很粗暴的方案。

跟搜索接口的响应时长相比，数据库并不像想象中的那么慢，同时写入的 qps 也远远没到数据库的瓶颈。

在负载不高的情况下，这个方案在性能上没有问题(实际上负载就没高过)。

如果写负载高到数据库难以承受(比如到几千qps，此时会影响同实例的其他业务)，也有把数据放到独立的数据库实例等~~加钱~~简单粗暴的优化方案。

如果负载高到单个数据库实例都难以承受(这时候写入qps得上万了)，还有经典的分库分表方案在等着，或者换成能支持更高写入 qps 的数据库。

> 虽然我一直没提缓存，但缓存也是可选项之一，具体选型要根据实际情况，综合考虑开发成本、维护成本(修复不一致数据)、机器成本来决策。

## 总结

除非在写算法题，或者真的在一个造火箭的公司，否则不需要提前考虑性能优化。

做好监控报警，遇到瓶颈后及时提醒就行。

当然，**不要提前优化**的重点在**不要提前**，并不是强行降智写烂代码。

如果已经有了可靠的数据支撑，

或者可以接受优化的成本(认知成本、开发成本、维护成本、机器成本)，

那就放手去优化。
